"""
Project Euler # 44 Pentagon Numbers

Pentagonal numbers are generated by the formula,
Pn=n(3n−1)/2. The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8.
However, their difference, 70 − 22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk,
for which their sum and difference are pentagonal and D = |Pk − Pj|
is minimised; what is the value of D?

---------------------------------------------------------------

Hacky Ruby and Crystal solutions. I generate an array of
10_000 pentagonal numbers, and only check those in order to
speed things up. I didn't have a good reason to choose 10_000,
I just tried it randomly. For every pentagonal number in
the array (j), I iterate over the array again (k), checking
to see if their sums and difference are pentagonal. 

I derived an equation for checking if a number is pentagonal
by solving for n in the P(n) formula (n = Sqrt(2 * P(n) + 1 / 3),
then plugging that back into P(n) so as to define P(n) without n,
which we don't have for any particular number which might be
pentagonal. I had already defined these lambdas for the next
problem (doing things out of order). A simpler solution might be
checking if the PENTS array includes the number in question,
however I think that would make things significantly slower.

The wording of the instructions was vague and I wasn't sure if
I'd get more than one value for the difference, and would have to
find the smallest one. So, initially, I collected all values in an
array. After the first run I realized that there were only 0's and
5482660's in the array. I believe there were zero's for the instances
when j == k. Anyway, I cleaned up the code a bit so that it simply prints
the first value it gets for the difference as long as that value isn't
0. Takes about 6 seconds in Ruby, and 0.24 seconds in Crystal.
"""


require 'benchmark'

b = ->(p) { Math.sqrt((2 * p + 1) / 3).ceil }
pn = ->(p) { b[p] * (3 * b[p] - 1) / 2 }
is_pentagonal = ->(p) { pn[p] == p }

pentagonize = ->(n) { n * (3 * n - 1) / 2 }

PENTS = (1..10_000).map { |x| pentagonize[x] }

Benchmark.bm do |x|
  x.report do
    d = nil
    PENTS.each do |j|
      PENTS.each do |k|
        next unless is_pentagonal[j + k]
        next unless is_pentagonal[(k - j).abs]
        d = (k - j).abs if (k - j).abs > 0
        break if d
      end
      break if d
    end
    puts d
  end
end

# user     system      total        real
# 5482660
# 5.940000   0.020000   5.960000 (  5.995233)
