"""
Project Euler # 44 Pentagon Numbers

Pentagonal numbers are generated by the formula,
Pn=n(3n−1)/2. The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8.
However, their difference, 70 − 22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk,
for which their sum and difference are pentagonal and D = |Pk − Pj|
is minimised; what is the value of D?

---------------------------------------------------------------

Hacky Ruby and Crystal solutions. I generate an array of
10_000 pentagonal numbers, and only check those in order to
speed things up. I didn't have a good reason to choose 10_000,
I just tried it randomly. For every pentagonal number in
the array (j), I iterate over the array again (k), checking
to see if their sums and difference are pentagonal. 

I derived an equation for checking if a number is pentagonal
by solving for n in the P(n) formula (n = Sqrt(2 * P(n) + 1 / 3),
then plugging that back into P(n) so as to define P(n) without n,
which we don't have for any particular number which might be
pentagonal. I had already defined these lambdas for the next
problem (doing things out of order). A simpler solution might be
checking if the PENTS array includes the number in question,
however I think that would make things significantly slower.

The wording of the instructions was vague and I wasn't sure if
I'd get more than one value for the difference, and would have to
find the smallest one. So, initially, I collected all values in an
array. After the first run I realized that there were only 0's and
5482660's in the array. I believe there were zero's for the instances
when j == k. Anyway, I cleaned up the code a bit so that it simply prints
the first value it gets for the difference as long as that value isn't
0. Takes about 6 seconds in Ruby, and 0.24 seconds in Crystal.
"""

require "benchmark"

def pentagonize(n : Int64)
  n * (3_i64 * n - 1_i64) / 2_i64 
end

PENTS = (1_i64..10_000_i64).map { |x| pentagonize(x) }

def find
  b = ->(p : Int64) { Math.sqrt((2_i64 * p + 1_i64) / 3_i64).ceil }
  pn = ->(p : Int64) { b.call(p) * (3_i64 * b.call(p) - 1_i64) / 2_i64 }
  is_pentagonal = ->(p : Int64) { pn.call(p) == p }

  d = 0_i64
  PENTS.each do |j|
    PENTS.each do |k|
      next unless is_pentagonal.call(j + k)
      next unless is_pentagonal.call((k - j).abs)
      d = (k - j).abs if (k - j).abs > 0_i64
      break if d > 0
    end
    break if d > 0
  end
  puts d
end

Benchmark.bm do |x|
  x.report("answer: ") { find }
end 
    
# user     system      total        real
# answer:  5482660
# 0.240000   0.000000   0.240000 (  0.247856)
